###

pwd=/usr/oracle/app/product/11.2.0.1/client/network/admin

ll

samples
shrept.lst
tnsnames.ora


testhost = 
	(DESCRIPTION =
		(ADDRESS_LIST = 
			(ADDRESS = (PROTOCOL = TCP) (HOST = 109.1.0.1) (PORT = 3306))
		)
		(CONNECT_DATA = 
			(SID = $ORACLE_SID)
		)
	)

###SID与SERVICE_NAME、TNSName

JDBC连接ORACLE的三种方式
格式一：jdbc:oracle:thin:@//<host>:<port>/<service_name>
格式二：jdbc:oracle:thin:@<host>:<port>:<SID> 
格式三：jdbc:oracle:thin:@<TNSName> 


jdbc:oracle:thin:@10.2.0.2:1521:orcl
jdbc:oracle:thin:@(DESCRIPTION =(ADDRESS_LIST =(ADDRESS =(PROTOCOL = TCP)(HOST = 10.2.0.2)(PORT = 1521)))(CONNECT_DATA =(SERVICE_NAME = orcl)))


 在讲解SID和SERVICE_NAME之前，先说一下实例。实例是操作系统中访问数据库所需要的一系列的进程和内存的集合。即使没有任何数据文件，实例也可以启动。但是要想访问数据库，必须把数据库文件加载进实例中。实例和数据库的区别可以简单概括为：实例是临时的，它只在相关的进程和内存集合存在时存在，而数据库是永久的，只要文件存在它就存在。一个实例只能对应一个数据库，但是一个数据库可以由多个实例对应（如RAC）。RAC就是多个实例同时打开一个数据库文件的系统，在结构上是多台机器，每台机器运行一个实例，每个实例都打开同一个数据库 （这个是用磁盘共享技术实现的），这些实例之间需要同步高速缓存，这样保证多个实例是完全一致的，不会相互冲突乃至覆盖。

SID即INSTANCE_NAME是用来唯一标示实例的。SERVICE_NAME是oracle8i新引进的，8i之前，一个数据库只能由一个实例对应，但是随着高性能的需求，并行技术的使用，一个数据库可以由多个实例对应了，比较典型的应用如RAC。为了充分利用所有实例，并且令客户端连接配置简单，ORACLE提出了SERVICE_NAME的概念。该参数直接对应数据库，而不是某个实例。


SERVICE_NAME的出现就是为了应对并发技术，简化客户端连接配置。通过SERVICE_NAME应该能找到更好的解决方案。通过查找JDBC帮助得知JDBC连接ORACLE的方法由三种：

JDBC是使用格式二连接的，使用RAC后实例增多了，SID已经不唯一，格式二已经无法完全利用所有资源。研发参考PL/SQL的连接方法刚好碰巧使用了格式三。因为java应用服务器跟数据库服务器是分离的，应用服务器上没有oracle的服务端以及客户端。虽然解决方案中没有使用TNSName,但是使用了TNSName的连接描述，效果是一样的。既然JDBC有三种连接方案，我们不妨再看一下第一种方案。再加上前面的讲解内容，我想大家已经都知道故事中的问题该怎么修改了，只要改成jdbc:oracle:thin:@//10.2.0.2:1521/orcl就可以了，而且这种格式也支持单实例数据库。这也是ORACLE在8i之后增加SERVICE_NAME的初衷。


###实例和数据库

从上面我们得出结论:数据库==磁盘上的文件.既然数据库可以看成磁盘上文件,我们怎么使用数据库呢?如果说我们可以直接使用数据库,那就等价与直接使用磁盘上的文件.我们知道这样的一个常识:必须把磁盘上的文件读入内存才能使用.这就与我们以前所知道的一个常识相违背了.
那正确的流程是不是应该这样呢?把磁盘上文件先读入内存,然后再使用呢.对了,这个才是使用数据库的正确流程.
数据库如何读入内存呢?
这个时候,就是我们要介绍的instance(实例)了.实例就是内存结构和一组后台进程.实际上,正常的数据库读入内存的过程是,由实例中一组后台进程从磁盘上将数据文件读入到实例的内存中,然后经过在内存中对数据的操作再从实例的内存中经过一组后台进程写到数据库中.
那实例相对与数据库而言,应该就是数据库的运行环境(随不准确但也很贴切).
        我们知道了instance和database的区别后.下面我们做一个Oracle的例子,一块深刻的理解下这两个概念.
        在Oracle中打开一个数据库,这个时候我们要使用sqlplus了.sqlplus是oracle的一个连接工具,相当于sql server中的查询分析器.

###ACID事务

事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，事务是一个数据库概念。但我理解数据库也是一款软件，只是遵循了数据库SQL标准，理解事务，先看看数据库软件的逻辑结构，这是mysql的逻辑结构：

MYSQL的逻辑结构：



```sql
update car set cars_Beijing=cars_Beijing-1 where id = 1; 
update car set cars_Shanghai=cars_Shanghai-1 where id = 1;
```
1. 原子性（atomicity）,就是说这个事务要么不执行，要么全部执行，就是上面2条语句，不允许只执行一条而不执行第二天语句的情况发生。 
2. 一致性（consistency），就是说数据库从一个一致性状态转移到另一个一致性状态，怎么理解呢，原子性是表示不允许只执行一条而不执行第二条的情况发生，那么一致性就是说要么第一条第二条都执行成功（所谓执行成功就是对数据库持久化数据产生了影响），要么就第一条第二条都执行失败（都不对数据库持久化数据产生影响），不允许一条成功，一条失败的情况。 
3. 隔离性（isolation）理解隔离性，就是隔离另一个线程（事务）的操作，比如线程A正在执行这个事务cars_Beijing–，cars_Shanghai++，线程B则正在查询cars_Beijing和cars_Shanghai的值，隔离性就要保证线程B只能查询到事务完全没有执行或者完全成功执行的值，不允许线程B查询到只执行了cars_Beijing–而没有执行cars_Shanghai++的值 
4. 持久性（durability），这个比较好理解，就是事务一旦提交，所修改的数据就被持久化，即使掉电也不会丢失。




前面说了隔离性是防止其他线程读到事务的中间值，但实际上这会分成情况，因为有很多种不同的中间值，也就对应了SQL标准中的4个隔离级别。 
理解隔离级别之前，先搞清楚两个问题。 
第一个是要实现事务的ACID性，其实和多线程编程中对公共资源的线程安全性原理差不多，怎么来保证这个ACID哩，当然就是对各线程的公共资源加锁了，线程要访问公共资源，就需要先获取公共资源的锁，这里的公共资源就是数据库里面的数据，我们知道关系型数据库中的数据是按表-行来分的，这里我是可以选择是对行加锁还是对表加锁，或者干脆对整个数据库加锁的问题。这就是锁的级别。 
第二个是多个线程对公共数据的操作其实也可以分成很多种情况，比如线程A在执行cars_Beijing–，cars_Shanghai++这个事务的时候，事务B可能正在读取相应字段的cars_Beijing值，也可能多次读取读取相应字段的cars_Beijing值，还有可能在统计car表的有多少条记录或者增加记录等等。 
知道了锁和其他线程对公共数据表的操作组合，我们再来理解SQL标准中的4个隔离级别，就会很容易了 
1. 未提交读（read uncommitted），就是不做隔离控制，可以读到“脏数据”，比如上面的cars_Beijing–，cars_Shanghai++，这个隔离级别允许其他线程读取到只做了cars_Beijing–而没有做cars_Shanghai++时候的值。显然这个隔离级别没有太大意义，现实中没有人会用，除非这个应用只有读取，没有任何写入。 
2. 提交读（read committed），提交读就是不允许读取事务没有提交的数据，简单的说，就是上面的cars_Beijing–，cars_Shanghai++，不允许读取到只做了cars_Beijing–，而没有做cars_Shanghai++的记录。这个隔离级别是大多数数据库（除了mysql）的默认隔离级别。 
3. 可重复读（repeatable read），什么是不可重复读，就是事务A去做cars_Beijing–，cars_Shanghai++之前，事务B启动了，先读取了一次事务A要修改的值，这个时候事务A修改了记录，但是事务B在事务A修改完后又读取了同一记录值，显然，这导致事务B相同的读取操作却读取了不同值，这就是不可重复读。可重复读就是禁止这种情况发生，比如对需要修改的数据加排他锁，事务B需要读取这个记录， 那么整个事务B没有完成之前，都允许事务A启动。可重复读的隔离级别是mysql默认的隔离级别。 
4. 可串行化（serialzable），就是多个线程（事务）完全不并发，串行执行，当然不会有任何隔离问题，显而易见效率也最低，一般不采用

还有一个问题，就是有什么问题可串行化能解决而可重复读不能解决？那就是幻读问题，什么叫幻读，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。可重复读由于只锁定需要修改的记录，如果一个事务的任务是增加一个记录，这个事务是不会被修改事务阻塞的，所有可重复读的隔离级别是不能解决幻读问题的

 Read Commit: 不加锁, Read Commit: 读-共享行锁, 写-排它行锁, Repeatable-Read: 读写-行排它锁, serialzable: 读写-表排它锁; 在MySQL中, 使用"for update"如果不是指定primary key, 那么加的全表排它锁, 不然就是行排它锁;


###OLTP与OLAP
OLTP和OLAP的区别

联机事务处理OLTP（on-line transaction processing） 主要是执行基本日常的事务处理，比如数据库记录的增删查改。比如在银行的一笔交易记录，就是一个典型的事务。 
OLTP的特点一般有： 
1.实时性要求高。我记得之前上大学的时候，银行异地汇款，要隔天才能到账，而现在是分分钟到账的节奏，说明现在银行的实时处理能力大大增强。 
2.数据量不是很大，生产库上的数据量一般不会太大，而且会及时做相应的数据处理与转移。 
3.交易一般是确定的，比如银行存取款的金额肯定是确定的，所以OLTP是对确定性的数据进行存取 
4.高并发，并且要求满足ACID原则。比如两人同时操作一个银行卡账户，比如大型的购物网站秒杀活动时上万的QPS请求。

联机分析处理OLAP（On-Line Analytical Processing） 是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。典型的应用就是复杂的动态的报表系统。

OLAP的特点一般有： 
1.实时性要求不是很高，比如最常见的应用就是天级更新数据，然后出对应的数据报表。 
2.数据量大，因为OLAP支持的是动态查询，所以用户也许要通过将很多数据的统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大; 
3.OLAP系统的重点是通过数据提供决策支持，所以查询一般都是动态，自定义的。所以在OLAP中，维度的概念特别重要。一般会将用户所有关心的维度数据，存入对应数据平台。

总结： 
OLTP即联机事务处理，就是我们经常说的关系数据库，增删查改就是我们经常应用的东西，这是数据库的基础；TPCC(Transaction Processing Performance Council)属于此类。 
OLAP即联机分析处理，是数据仓库的核心部心，所谓数据仓库是对于大量已经由OLTP形成的数据的一种分析型的数据库，用于处理商业智能、决策支持等重要的决策信息；数据仓库是在数据库应用到一定程序之后而对历史数据的加工与分析，读取较多，更新较少，TPCH属于此类。 
随着大数据时代的到来，对于OLAP，列存储模式或者说nosql模式比传统意义的行存储模式可能更具优势。



